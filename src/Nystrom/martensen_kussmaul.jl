# using SpecialFunctions; # need to evaluate the Hankel function (Green's function)
# using Luxor;  # this package is needed to indentify the points inside/outside the curve
# using Plots;
#--------------------------------------------------------------------------------------- 
# struct Curve
#     name::String
#     N::Int64               # number of nodes
#     x::Array{Float64,2}    # nodes on the curve generated by a parametrization
#     dx::Array{Float64,2}   # 1st derivative of the curve parametrization at the nodes 
#     d2x::Array{Float64,2}  # 2nd derivative of the curve parametrization at the nodes 
#     d3x::Array{Float64,2}  # 3rd derivative of the curve parametrization at the nodes     
#     τ::Array{Float64,1}    # norm of the derivative of the curve parametrization at the nodes
#     ν::Array{Float64,2}    # unit normal at the nodes
#     Δs::Float64            # discretization size in parameter space (~2*pi/N)
#     s::Array{Float64,1}    # discrete values of the parameter 
#     ds::Array{Float64,1}   # derivative of the sigmoid change of variable (for curves with corners)
#     R::Array{Float64,2}    # Nystrom weights
# end
#--------------------------------------------------------------------------------------- 
# function NystromWeights(M)
#     R = zeros(2*M,2*M);
#     for p=1:2*M            
#         tp = pi/M*(p-1);
#         for j=1:2*M
#             tj = pi/M*(j-1);
#             R[p,j]=-2*pi/M*sum((ones(M-1)./collect(1:M-1)).*cos.(collect(1:M-1)*(tp-tj)))-pi/(M^2)*cos(M*(tp-tj));               
#         end            
#     end
#     return R
# end

function nystrom_weights(M)
    @assert M%2 == 0  "number of points `M` must be even"
    Md2 = div(M,2)    
    R   = zeros(M,M)
    for p=1:M            
        tp = pi/Md2*(p-1)
        for j=1:M
            tj = pi/Md2*(j-1)
            R[p,j]=-2*pi/Md2*sum((ones(Md2-1)./collect(1:Md2-1)).*cos.(collect(1:Md2-1)*(tp-tj)))-pi/(Md2^2)*cos(Md2*(tp-tj))
        end            
    end
    return R
end

function assert_mk_compatibility(iop::IntegralOperator,mesh::NystromMesh)
    # write the various checks regarding compatibility 
    # a) 2d problem
    # b) only closed entities
    # c) closed entites must be discretized using a single element (global
    # quadrature)
end    

function self_interaction(iop::IntegralOperator,mesh::NystromMesh)
    assert_mk_compatibility(iop,mesh)    
    E     = etypes(mesh) |> first
    els   = mesh.elements[E]
    qrule = mesh.etype2qrule[E]
    x̂,ŵ   = qrule()
    @assert length(els) == 1 # global quadrature
    el  = first(els)
    dx =  [Geometry.derivative(el,u)/(2π) for u in x̂]
    d2x = [Geometry.derivative2(el,u)/(4*π^2) for u in x̂]
    τ   = [norm(τ) for τ in dx]
    ν   = qnormals(mesh)    
    s   = x̂
    x   = qnodes(mesh)
    N   = length(x)
    R   = nystrom_weights(N)
    Δs  = 2π / N
    S  = zeros(ComplexF64,N,N)
    D  = zeros(ComplexF64,N,N)
    psi = -0.577215664901532;
    pde = iop.kernel.op
    K   = SingleLayerKernel(pde)
    dK  = DoubleLayerKernel(pde)
    k   = iop.kernel.op.k
    φ   = mk_split(K)
    ψ   = mk_split(dK)
    for i=1:N,j=1:N
        lSin = log(4*(sin(Δs*(i-j)/2))^2) # singular part factored
        r    = norm(x[i]-x[j])
        J1   = besselj1(k*r)
        H1   = hankelh1(1,k*r)
        if i != j
            S1   = φ(x[i],x[j])*τ[j]
            D1   = ψ(x[i],x[j],ν[j])*τ[j]
            S2   = K(x[i],x[j])*τ[j]-S1*lSin # what is left after factoring out lSin and φ
            D2   = dK(x[i],x[j],ν[j])*τ[j]-D1*lSin
        else # limit taken "by hand"
            S1   = φ(x[i],x[j])*τ[j] # always regular    
            S2   = (im/4+psi/2/pi-1/4/pi*log(k^2/4*τ[j]^2))*τ[j]
            D1   = 0.0
            D2   = -1/(4*pi)*(dx[j][1]*d2x[j][2]-dx[j][2]*d2x[j][1])/τ[j]^2
        end 
        S[i,j] = (R[i,j]*S1 + Δs*S2)
        D[i,j] = (R[i,j]*D1 + Δs*D2)
    end
    return S,D
end

# analytical splitting of kernel in 2d
function mk_split(SL::SingleLayerKernel{T,S}) where {T,S<:Helmholtz}
    k = SL.op.k
    ϕ = (x,y) -> begin
        d = norm(x-y)
        (-1/(4*pi))*besselj0(k*d)
    end
    return ϕ
end    

function mk_split(DL::DoubleLayerKernel{T,S}) where {T,S<:Helmholtz}
    k = DL.op.k
    ϕ = (x,y,ν) -> begin
        r = x-y
        d = norm(r)
        (-k/(4*pi))*besselj1(k*d)/d*dot(r,ν)
    end
    return ϕ
end    
